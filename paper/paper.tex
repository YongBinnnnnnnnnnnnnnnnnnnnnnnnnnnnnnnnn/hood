\documentclass[mscthesis]{usiinfthesis}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{float}
\usepackage{cleveref}
\usepackage{makecell}
\usepackage{colortbl}
\usepackage{pdflscape}

\usepackage{listings}

\lstdefinelanguage{algebra}
{morekeywords={import,sort,constructors,observers,transformers,axioms,if,
else,end},
sensitive=false,
morecomment=[l]{//s},
}



\title{Design and implementation of a firewall system for working in unsafe environments} %compulsory
\mastermajor{Financial Technology and Computing}%optional
\specialization{main track}
%\subtitle{Subtitle: Reinventing the World} %optional 
\author{Bin Yong} %compulsory
\begin{committee}
\advisor{Prof.}{Student's}{Advisor} %compulsory
\coadvisor{Prof.}{Student's}{Co-Advisor}{} %optional
\end{committee}
\Day{2} %compulsory
\Month{February} %compulsory
\Year{2024} %compulsory, put only the year
\place{Lugano} %compulsory

%\dedication{To my beloved} %optional
%\openepigraph{Someone said \dots}{Someone} %optional

%\makeindex %optional, also comment out \theindex at the end

\begin{document}

\definecolor{tablegray}{gray}{0.85}

\maketitle %generates the titlepage, this is FIXED

\frontmatter %generates the frontmatter, this is FIXED

\begin{abstract}
  \paragraph{}
  Design and implementation of a firewall system based on Raspberry Pi. The firewall monitors network activities, encrypts some plaintext traffic, and alerts invalid certificates. It helps device owners take back control of their own devices. It is designed for someone who needs to work in unsafe environments. The system sacrificed some compatibility to pursue better security but still achieved a balance between security and convenience. Decisions are made by the combination of the analyzation to security events and my past experience. A sensitive target, like an investigative journalist, could be a potential user of this device. The firewall showed success protection against DNS hijacking, man-in-the-middle attacks, and port scanning. It successfully blocked some management tools, and decreased the data visibility to eavesdropping attacks.
\end{abstract}

\begin{acknowledgements}
  \paragraph{}
  This document is licensed under Creative Commons BY-NC-ND 4.0.
\end{acknowledgements}

\tableofcontents
\listoffigures %optional
\listoftables %optional

\mainmatter

\chapter{Introduction}
\paragraph{}
With the development of surveillance and management tools, people are losing control of their own devices. Here are some facts that the general public may underestimated the impacts of their combinations:

\begin{enumerate}
  \item Any device with a microphone (sometimes a speaker may do the same) can 'hear' sounds people are making around.
  \item Any device with a camera can 'see' what is happening around.
  \item Any device connected to internet can upload what they know and receive commands from remote.
  \item Any device may have been hacked and functioning as not what they were designed.
  \item Some devices are designed with surveillance functionality.
\end{enumerate}
Based on the facts above, many devices could be used as surveillance tools. For example, smartphones and smart speakers are both able to hear voices and communicate with the internet. Most people do not have the skills to investigate and monitor what they actually uploaded to a remote server. To be able to respond to "Hi, Siri." or "Hey, Alexa.", devices have to process every sound they receive when they are quiet. Some are even worse: Intel Management Engine (Intel ME) or Intel Converged Security and Management Engine (Intel CSME) and Intel Active Management Technology (Intel AMT) for example. Obviously, they are made for management, a function that is unnecessary to most individual owners. According to their official documents. "even when the platform is powered off, as long as the platform is connected to power and to a network" \citep{ime:csmewp} means that simply powering off the computer could not stop this kind of management. "up before the main operating system" \citep{ime:power} means that most users could not even notice it and could do nothing about it, and if something goes wrong, people cannot fix it by simply reinstalling operating system. It can access "LAN/Wireless LAN" \citep{ime:csmewp}, check the facts. "present on most Intel platforms, including client consumer and commercial systems, workstations, servers, and IoT (Internet of Things) products." \citep{ime:csmewp} means there is almost no escape in their ecosystem. The details of its documents also show the capability to tunnel remote commands (Serial Over Local-Area Network \citep{ime:csmewp}), the capability of accessing local storage "Universial Serial Bus Redirect" \citep{ime:csmewp}, "Keyboard, Video and Mouse" \citep{ime:csmewp} remote control over network. Besides, A person may accept rules of the management functionality, but the criminal will not tell the person when the functionality is misused.
\paragraph{}
So many things are out of the control of the owners of the devices. People need something to restrict the management and to show what is happening to the network. The goal of this work is to help with that. It aims to increase the chance of survival of the user from hacking, eavesdropping, digital fingerprinting, and unwanted managements. It uses a screen to display selected real-time network activities. The system limits network activities and applies encryption standards.
\paragraph{}
Using hardware firewalls has several advantages over software firewalls. A hardware firewall is a physical device that plays the role of firewall, while software firewalls are usually software components that run inside a user's computer which also works for other purpose. Firstly, a hardware firewall runs completely independent to high-risk user devices, where unsafety thrives: CPU with possible hidden instruments, firmware with possible infections, motherboards with doubtable proprietary management technologies, and applications with possible surveillance or unpublished vulnerabilities. Second, it brings convenience to the user: the configuration of this portable device restricts everything behind it, so people do not need to do the time-consuming configuration work on different software and operating systems repeatedly. Third, it brings possibilities: Untrusting a built-in root certificate on mobile devices is hard and the methods with root or jailbreak involved may void the warranty. With the help of a firewall, managing certificates is no longer a problem.
\paragraph{}
This paragraph introduces the structure of this paper. In \cref{cha:hard}, The decisions behind the hardware selection and the operating system selection are explained, and the cost comparsion to commercial devices is made. It proved the low-cost of this system. The general decisions about how packets are forwarded are included in \cref{cha:packet}. In \cref{cha:dhcp,cha:dns,cha:tls}, the deficiency of the network protocols that are being used or allowed are discussed and the conter measurements are provided. In \cref{cha:plaintext}, we discuss how the firewall handle and process plaintext and other protocols. In \cref{cha:time}, the problem of using Network Time Protocol (NTP) is discussed and a new method to synchorize time between computer and internet is designed and implemented. In \cref{cha:simulation}, a command-line tool to simuluate network activities is designed and implemented. It is a tool being shipped with the firewall system but it needs to be executed manually by the user. In \cref{cha:dispatcher}, the dispatcher, the script to react to changes of the system, is introduced. The \cref{cha:install} explains how the firewall is installed to the base operating system and explains the reasons why some system files are modified. In \cref{cha:test} various attacks are used to test the firewall and the results show the success of protection.

\chapter{Hardware and operating system}\label{cha:hard}
\section{Design}
\paragraph{}
"hood" (see \cref{sec:hood}) should work as a USB Ethernet device by default, so people do not need to connect many cables. See \cref{fig:hardware-deployment-view}. With proper configurations, the device can also work as a wireless access point or a wireless USB Ethernet device. The cost of the hardware should be lower than the average price of a commercial hardware firewall.
\begin{figure}[H]
  \centering
  \includegraphics[scale=0.5]{graphics/puml/hardware-deployment-view.png}
  \caption{Default hardware deployment view}
  \label{fig:hardware-deployment-view}
\end{figure}

\section{Implementation}
\subsection{USB device}
\paragraph{}
To make computers recognize the firewall as a USB device, the support from both the hardware and the operating systems (OS) are required.
\paragraph{}
For hardware, Raspberry Pi 4 is the first model in Raspberry Pi family that both supports USB device mode and contains an Ethernet port. Raspberry Pi 5 can do the same but it is more expensive.
\paragraph{}
For OS, Linux has USB gadget mode. Using the combination of CDC-ECM (See \cref{sec:CDC-ECM}) and Remote Network Driver Interface Specification (RNDIS, see \cref{sec:RNDIS}) mode, most Linux, Windows, BSD, and macOS could be supported. FreeBSD USB stack has a device mode and provides 3 virtual network interface templates but none of them works with Microsoft Windows\citep{freebsdhb:usb}. OpenBSD has renowned security-focused nature but it does not contain a device mode in its USB stack. Thus, to support as many devices as possible, Linux is selected as the base OS of this firewall device.

\subsection{The base hardware}
\paragraph{}
This paragraph explains the reasons of using Raspberry Pi. Since its first release in 2012, Raspberry Pi has upgraded its hardware models and software multiple times, has accumulated a lot of real-world applications, and has maintained an active user community with a large number of experienced users behind it. All of them show that by using Raspberry Pi instead of a cheap new brand, reduced time cost could be expected on fixing the bugs of the computer itself or waiting for the answers from the community because its users have asked and answered many questions and have found and fixed many problems. Besides, its large number of users could also help in spreading the firewall project and help in pointing out security flaws of the new upgrades to the computer.
\paragraph{}
Joy-IT RB-TFT3.5 was the only screen that I had. The dtbo file (see \cref{sec:dtbo}) of the Waveshare 35A screen also works with this hardware. Thus, the cheaper one in the market should be able to replace another. The resolution of 480x320 is enough for printing logs.

\section{Cost comparison to the market}
\subsection{Theory of the cost}
\paragraph{}
Commercial firewalls are usually more expensive than development boards that contain the same level of hardware functionality. On one hand, It's acceptable because they provided additional value through their software and services and all of the development and maintenance of the product, the service, and the company itself are costing money. On the other hand, it also indicates that an open-source solution would reduce the lower bound of the cost of accessing a hardware firewall.

\subsection{Market research on commercial firewalls}
\paragraph{}
Despite the firewall implemented in this paper is not a general-purpose firewall, the difference in cost between market products is still worth knowing. From \cref{tab:amazon-search,tab:amazon-search-stat}, the prices of hardware firewalls are concentrated around 250.74 EURO and most of them are more expensive than the price of a Raspberry Pi 4B (68.79 EURO) selling at the same website. The only exception is TP-LINK ER605. Its price is 55.5 EURO which is still higher than the price of a Raspberry P 3B on the same website. After checking the details of this exception, its central management design and the corresponding cloud-based controller both show that it is designed for a totally different threat model. Its exceptional price could be explained as the device is under the control of the company. However, spending money on a hardware firewall usually implies the reluctance to give control of devices to a company. To sum up, using Raspberry Pi would cost less than usual general-purpose firewalls.

\iffalse
  >>> x=[55.49,188.99,259.00,279.99,146.53,279.00,102.53,284.87,221.99,265.00,520.90,288.99,318.09,173.5,242.99,384.00]
  >>> sum(x)/len(x)
  250.74125000000004
  >>> import statistics
  >>> statistics.median(x)
  262.0
  >>> min(x)
  55.49
  >>> max(x)
  520.9
  >>> statistics.stdev(x)
  109.9844098573369
  >>> x=[188.99,259.00,279.99,146.53,279.00,102.53,284.87,221.99,265.00,288.99,318.09,173.5,242.99,384.00]
\fi
\begin{table}[H]
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|p{113mm}|p{12mm}|}
    \hline
    Name & Price   \\
    \hline
    \texttt{TP-LINK ER605 5 Port Dual/Multiple WAN VPN Router (up to 4 Gigabit WAN Ports, Highly Secure, Omada SDN, Central Management, Intelligent Monitoring, Firewall) Black, Ideal for Office Network
    }    & €55.49  \\
    \texttt{Micro Firewall Appliance, Mini PC, Pfsense Plus, Mikrotik, OPNsense, VPN, Router PC, Intel N4505, HUNSN RS41k, AES-NI, 4 x 2.5GbE I226-V, Console, Type-C, HDMI, DP, SIM Slot, 4G RAM, 32G SSD
    }    & €188.99 \\
    \texttt{ZyXEL ZyWALL 350Mbps VPN Firewall, Recommended for up to 10 Users [USG Flex 50]
    }    & €259.00 \\
    \texttt{Micro Firewall Appliance, Mini PC, pFsense Plus, Mikrotik, OPNsense, VPN, Router PC, Intel Alder Lake-N 12th Gen N100, HUNSN RJ42, 4 x 2.5GbE I226-V, 2 x HDMI, DP, TF, Type-C, 8G DDR5 RAM, 128G SSD
    }    & €279.99 \\
    \texttt{KingnovyPC Firewall Micro Appliance, 4 Port i226 2.5GbE LAN Fanless Mini PC N5100, 2* DDR4, HDMI, DP, RJ45 COM, 4*USB Gigabit Ethernet AES-NI VPN Router Openwrt Barebone
    }    & €146.53 \\
    \texttt{New J4125 Quad Core Firewall Micro Appliance, Mini PC, Nano PC, Router PC with 8G RAM 128G SSD, 4 RJ45 2.5GBE Port AES-NI Compatible with Pfsense OPNsense
    }    & €279.00 \\
    \texttt{Cisco Meraki Go - 5 Port Security Gateway - Power Supply to EU Standard GX20-HW-EU
    }    & €102.53 \\
    \texttt{Protectli Vault FW4B - 4 Port, Firewall Micro Appliance/Mini PC - Intel Quad Core, AES-NI, 4GB RAM, 32GB mSATA SSD - Compatible with pfSense/OPNsense etc
    }    & €284.87 \\
    \texttt{Firewall Hardware, Pfsense, OPNsense, Mikrotik, VPN, Network Security Appliance, Router PC, Intel Atom N2600, HHUNSN RS31, 4 x Intel Gigabit LAN, 2 x USB, COM, VGA, Fan, 4G RAM, 32G SSD
    }    & €221.99 \\
    \texttt{Firewall Mini PC with 2.5G Gigabit LAN, Firewall Micro Appliance Celeron J4125,4 x I225 Gigabit LAN,Fanless Mini PC AES-NI,12V,WiFi,HDMI,RS232 COM,USB 3.0,8GB RAM/128GB SSD
    }    & €265.00 \\
    \texttt{FORTINET FortiGate 40F Hardware - Next Generation Firewall Protection and Security
    }    & €520.90 \\
    \texttt{Micro Firewall Appliance, Mini PC, VPN, Router PC, Intel Alder Lake-N 12th Gen N100, HUNSN RJ42, 4 x 2.5GbE I226-V, 2 x HDMI, DP, TF, Type-C, Barebone, NO RAM, NO Storage, NO System
    }    & €288.99 \\
    \texttt{Cisco Systems Go Router Firewall Plus | Cloud Managed | VPN | Cisco [GX50-HW-EU], White
    }    & €318.09 \\
    \texttt{Zyxel Secure Cloud-Managed Router/Firewall with AXE5400 Tri-Band WiFi Subscription Free Network Security, Managed via Nebula APP/Ideal for Small Offices/Small Branches. [SCR 50AXE]
    }    & €173.5  \\
    \texttt{Micro Firewall Appliance, Mini PC, VPN, Router PC, Intel Alder Lake-N 12th Gen N100, HUNSN RJ46, 6 x 2.5GbE I226-V, 2 x HDMI2.1, TF, Type-C, Barebone, NO RAM, NO Storage, NO System
    }    & €242.99 \\
    \texttt{HSIPC 11th Gen i3 1115G4 Firewall Micro Appliance, Mini PC, Nano PC, Router PC (16G 256G) With 6 RJ45 2500M, AES-NI, HDMI USB3.0 Console, Compatible with Pfsense OPNsense
    }    & €384.00 \\
    \hline
  \end{tabular}
  \caption{The first page of search results of "hardware firewall" on amazon.de. Captured at 5 P.M. of December 26th, 2023 (UTC +1), Lugano}
  \label{tab:amazon-search}
\end{table}

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|c|}
    \hline
    \multicolumn{4}{|c|}{Statistics of the prices in search results}                         \\
    \hline
    Mean                                     & 250.74                      & Median & 262.0  \\
    \hline
    Min                                      & 55.49                       & Max    & 520.89 \\
    \hline
    \multicolumn{2}{|c|}{Standard deviation} & \multicolumn{2}{c|}{109.98}                   \\
    \hline
  \end{tabular}
  \caption{Statistics of \cref{tab:amazon-search}}
  \label{tab:amazon-search-stat}
\end{table}

\subsection{Conclusion}
\paragraph{}
In conclusion, Raspberry Pi 4B has sufficient hardware and software support to make it work as the USB device designed in the first section. Its price is also much lower than the majority of commercial firewalls. It is not the cheapest option that can fit the design, but it is a good choice after evaluating technical support and user base.

\chapter{Packet filtering and forwarding in general}\label{cha:packet}
\section{Design}
\paragraph{}
As the general principle, all traffic passed through firewall should be checked against eavesdropping. Plaintext protocols should be channeled through strong encryptions or discarded if unable to ensure their integrity. Firewall rules should filter out as much as possible and as early as possible because everything on the path of a packet is potentially vulnerable, and the less network traffic passed to the following components, the less chance a vulnerability can affect the firewall.

\paragraph{}
Network traffic should be forwarded by proxies instead of kernel. The following content explains the advantages of doing so. First, a proxy can run at the user level. When there is a vulnerability, a userland one naturally be less harmful than a kernel one. Second, proxies are easier and also safer to configure. It's hard to configure operating system firewalls well. When the rules are not strict enough, unexpected things may happen. For example, allowing any connection to 127.0.0.1 to succeed without a log, could cause potential problems if a malicious Dynamic Host Configuration Protocol (DHCP, see \cref{cha:dhcp}) server assigned the address 127.0.0.1 to a physical network interface. Also, simply filtering packets by port numbers, addresses, and interfaces could not guarantee that allowed packets are used by the desired protocol. An attacker can simply let the receiving end of a reverse shell listen to an allowed port to bypass this kind of defense. By contrast, a proxy only works for the protocols it can understand. For example, the chance of misconfigurations of a DNS proxy enabling HTTP requests to pass over that proxy is very rare. Attackers have to hack the firewall or create tunnels over those protocols to make their reverse shell bypass the firewall, which makes their operations more difficult. Third, the packets from the proxy are encoded again by the Linux network stack. Re-encoded packets have only Linux TCP and IP signatures, rendering fingerprinting techniques that target TCP and IP properties useless.

\section{Implementation}
\paragraph{}
The balance between compatibility and security: To maximize compatibility, the firewall should allow everything to pass through it, regardless of protocol and destination, but to maximize security, nothing should be able to pass through the firewall. As a balance, modern browsers can satisfy most of the needs for working. So, allowing only HTTP and HTTPS connections could make most of the work done when facing a hostile network environment.
\paragraph{}
Nftables (see \cref{sec:nftables}) is integrated into modern Linux systems. It can classify and filter network traffic. The firewall uses it to filter network packets. UDP 67 or 68 port and ARP packets are allowed for assigning IP addresses. UDP 53 is allowed for users to make DNS requests to the firewall device, TCP 80, and TCP 443 are allowed for HTTP and HTTPS traffic. All other packets are filtered as early as possible.
\paragraph{}
Different proxies and services are created to check connections, to forward traffic, and to apply encryptions. Details are included in the chapters of corresponding protocols. See \cref{fig:http-process-view,fig:ocsp-process-view,fig:tls-process-view}. Several configuration files are created for blocking IP subnets and domain names, they are used by proxies and services. See \cref{sec:domain_blacklist.txt,sec:ip_subnet_blacklist.txt,sec:allowed_tls_ports.txt}.

\chapter{Dynamic Host Configuration Protocol (DHCP)}\label{cha:dhcp}

\section{Introduction}
\paragraph{}
DHCP is widely used to dynamically assign an IP address to a new device connected to a network.

\subsection{The issue}
\paragraph{}
The issue is that information leaked by protocol can be used to identify the owner of the device. The host name of the device could be leaked to the network from the 'client identifier' option or the 'sname' field in the protocol.\citep{rfc:dhcp} If the name of a computer is straightforward enough, like "Yongbin's MacBook Pro", the network administrator will be able to know the name of the owner of the computer at first glance. The hardware address exposed to the network can also reveal more information than just the address. Hardware address or Media Access Control (MAC) address can be used to reverse lookup the manufacturer and the manufacturer can help identify the owner. For example, the network administrator may use the prefix of a MAC address to find out that the manufacturer of the device is company A. If company A only sells its products in Country B and C is the only person who had ever been to Country B then the chance that the device belongs to C would be high.

\section{Design}
\paragraph{}
Firewall should randomize both host name and MAC address. The randomized computer name should look normal to prevent being spotted easily.

\lstdefinelanguage{conf}{
basicstyle=\ttfamily\small,
columns=fullflexible,
morecomment=[s][\color{purple}\bfseries]{[}{]},
morecomment=[l]{\#},
commentstyle=\color{gray}\ttfamily,
morekeywords={},
otherkeywords={=},
keywordstyle={\color{green}\bfseries}
}

\section{Implementation}
\paragraph{}
NetworkManager is used to manage physical connections of the firewall. The MAC address randomization is done by NetworkManager by adding 'ethernet.cloned-mac-address=random' and 'wifi.cloned-mac-address=random' to the 'connection' section of NetworkManager.conf. The 'ifconfig interface link random' command can also randomize the MAC address of an interface manually.
\paragraph{}
Host names of the firewall device are randomly generated during the startup of the system. The relevant code is inside rc.local. The generated host name is crafted to look normal. The pattern of default computer names of Microsoft Windows and common names like iPad are used. Because the implementation of the DHCP client could also be vulnerable, AppArmor (see \cref{sec:AppArmor}) rules are applied to dhclient to mitigate this problem.
\paragraph{}
Dnsmasq is used to assign the IP address of the users of the firewall it also tells the devices behind the firewall to use the firewall as the DNS resolver.

\chapter{Domain Name System (DNS)}\label{cha:dns}

\section{Introduction}
DNS is a protocol that translates the human-readable domain names to the IP addresses of the remote server. The default configurations of many operating systems are to make plaintext requests, which could easily be monitored by simply recording the packets and could easily be attacked by methods like DNS spoofing.

\section{Design}
\paragraph{}
From the network administrator's view, all DNS queries sent out from the firewall should be encrypted. From the user's view, nothing should need be specially configured.

\section{Implementation}
\subsection{Outgoing requests}
\paragraph{}
The firewall system created hood-name-service.py to resolve domain name queries from other firewall services. It is a local remote procedure call (RPC) service that resolves domain name queries via public DNS-over-HTTPS (DoH) services. DoH can mitigate both passive surveillance and DNS spoofing attacks\citep{rfc:doh8}. DNS-over-TLS (DoT) is another DNS encryption standard that can do almost the same as DoH. The advantage of DoH over DoT is that DoT uses a unique server port number, 853, that can be easily filtered or identified as an encrypted DNS connection, while DoH uses the same port number and protocol as HTTPS, which makes it much harder to be identified or filtered.
\subsection{Inside firewall}
\paragraph{}
A dnsmasq is started locally to resolve everything to localhost to make the firewall proxies system-wide.
\subsection{Incoming requests}
\paragraph{}
A dnsmasq is started to resolve everything to the firewall device to make the firewall proxies apply to devices behind it.

\chapter{Transport Layer Security (TLS)}\label{cha:tls}

\section{Management of certificates}

\subsection{Introduction}
\paragraph{}
Modern major operating systems manage a collection of selected trusted certificates issued by certificate authorities (CAs). Those certificates are used to prove the validity of a public key. When making a TLS connection, local applications check the path of the certificate provided by remote with a local trusted collection to ensure secure connections.
\subsubsection{The issue}
\paragraph{}
The problem is that most of TLS clients do not alert their users when the remote website presents a different certificate, which gives CAs the power to do man-in-the-middle (MITM) attacks. Even if a CA has no intention to do evil, its private key could still have been stolen. Thus, none of them are strictly trustworthy. However, the whole TLS is based on it, if we trust none of those authorities, there will be almost no website we can use and without TLS, things will only be worse.
\subsubsection{Exsting solutions}
\paragraph{}
Certificate pinning can prevent MITM attacks from a trusted CA. When the user knows the CA of the remote endpoint is A, if another CA does the MITM attack, the client could know that the certificate received is not the correct one because it is not issued by A. However, configuring certificate pinning to all the endpoints is hard and time-consuming for average users, and without a basic trusted environment, people are unable to know whether the configuration has been done correctly. Even if the configuration is correct, it is still not strange for an endpoint to switch to another CA. Thus, to a firewall, this technique cannot be used as a general solution to the issue.
\paragraph{}
Removing suspicious CAs from the trusted list could protect people from MITM attacks initiated by those CAs. However, some systems and devices do provide the function of untrusting a CA. For example, an iPhone needs a computer to enable such configuration and most Android devices do not provide such entry in settings.
\subsection{Design}
\paragraph{}
The firewall should trust only the CAs that are being widely used on the internet. It now respects th usage statistics of SSL certificate authorities for websites published by W3Techs \citep{cert:stat} with some exceptions added for my work. People should be able to further decide which certificates to trust. Consider untrust following CAs when making such decisions: the CAs of the place you are staying, the CAs of the place you come from, and their enemies and allies.
\subsection{Implementation}
\paragraph{}
Since SSL pinning can only be used on a small number of endpoints by an advanced user who can clearly know what is this meant to be, it is not implemented now. Manually management of the certificate can be done by Linux commands. The certificates of all remote TLS endpoints are checked by TLS proxy.

\section{Mismatch between the changing best current practice and the unchanged implementation}
\subsection{Problem}
The mismatch problem occures whenever a public protocol standard updated to fix a problem. There are delays between the time of a deficiency of a protocol being published and the time of the majority of the implementation fixed the problem. A living example is the latest version of Python 3.12.1 released on December 2023, as part of its built-in libraries, the implementation of the function create\_default\_context() from the SSL library is still creating a context that supports TLS 1.0 and TLS 1.1 by default \citep{pyton:ssl}, while they have already been deprecated by the best practice rfc8996 since March 2021 \citep{rfc:notls11}.

\subsection{Solution}
An idea to save the clients that contain severe deficiencies is to attack their deficiencies and then hijack and channel their communication to remote endpoints through the TLS connection with the current best practices applied. Applying this methology to solve the downgrade attack of Secure Socket Layer (SSL) version 2.0 was the initial motivation of the works on the TLS proxy, but due to the drastic changes to the protocol since SSL 2.0, the final implementation is instead to use the proxy to check whether the best practice is applied.


\section{Proxy}
\subsubsection{Design}
\paragraph{}
The proxy should filter out the connnections that are negotiated to use cipher suites not recommended by RFC best practice by checking the handshake packets. It should also filter out the connections that are using certificates signed by CAs that are not trusted by the firewall system. So that even if the user device has a pre-installed malicious certificate, the certificate will be filtered by firewall and the MITM attack will fail.
\paragraph{}
The proxy should not use the MITM attack to decrypt SSL sessions. Despite using MITM attack to inspect or protect encrypted connections has been used in firewalls and proxies for many years \citep{fortigate:deepinspection}, the TLS proxy used in this firewall should not implement the same functionality. The reason is that when the firewall itself is compromised, the ability to decrypt TLS sessions will cause a disaster to the devices behind it: the attacker will be able to easily modify the encrypted data transferred over a MITM proxy while the devices behind the firewall will alert nothing about the modification. However, if the firewall could not do MITM attacks at all, the compromised firewall is still unable to see and modify encryptions, because the certificate verification of the devices behind this firewall is still working.
\subsubsection{Implementation}
\paragraph{}
Since TLS proxy is in charge of processing and forwarding the majority of the traffic of the firewall, c++ is used to develop the proxy due to its high-performance capability.
\paragraph{}
This paragraph explains how the proxy filters certificates. The key\_share extension sometimes makes the certificate invisible to the proxy. Thus, to filter certificates, the proxy handshakes with the remote server with a separate connection to verify the certificate used by the remote host. A cache of trusted endpoints is used to reduce delays caused by certificate check connections.
\paragraph{}
\cref{fig:tls-proxy-process-view} shows how hood-tls-proxy receives and processes TLS connections.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{graphics/puml/process-tls-proxy.png}
  \caption{Process view of TLS proxy}
  \label{fig:tls-proxy-process-view}
\end{figure}

\paragraph{}
This paragraph explains how the proxy checks the ClientHello of TLS hanshake. Upon receiving ClientHello from a client, the proxy first checks the version of the protocol, and the supported\_versions extension to see if the client supports establishing a safe TLS channel, TLS 1.1 and TLS 1.2 are the only allowed versions \citep{rfc:bstprc}, if a ClientHello shows that the client supports neither, it will be discarded. After the version check, the proxy checks the ciphersuites field, if it contains none of the values listed in \cref{lst:tls-ciphersuites}, it will be considered unable to be safe and discarded \citep{rfc:bstprc}. If a ClientHello passed all of the security checks, the proxy will extract the Server Name Indication (SNI) from the ClientHello to determine the actual destination of the request. Strengthen the connection by modifying handshake packets without MITM is not possible because the HMAC of all handshake packets is used for encryption.

\begin{table}[H]
  \begin{itemize}
    \item TLS\_ECDHE\_RSA\_WITH\_AES\_128\_GCM\_SHA256
    \item TLS\_ECDHE\_RSA\_WITH\_AES\_256\_GCM\_SHA384
    \item TLS\_ECDHE\_ECDSA\_WITH\_AES\_128\_GCM\_SHA256
    \item TLS\_ECDHE\_ECDSA\_WITH\_AES\_256\_GCM\_SHA384
    \item TLS\_AES\_128\_GCM\_SHA256
    \item TLS\_AES\_256\_GCM\_SHA384
    \item TLS\_CHACHA20\_POLY1305\_SHA256
  \end{itemize}
  \caption{Allowed cipher suites values}
  \label{lst:tls-ciphersuites}
\end{table}

\paragraph{}
Following content explains how the proxy resolve host names and select trusted endpoints. The proxy first checks if there are any cached trusted endpoints available, if not it uses a RPC call to hood-name-service.py to resolve the domain name. Then TLS handshakes following the same restrictions to the ClientHello check are made to all of the addresses returned from the name service. The handshake process will not only ensure remote endpoint meets the requirements (versions and ciphersuites) of applying the best practices described in rfc9325, it will also check whether the remote endpoint could provide a valid certificate of the hostname from a trusted CA of the firewall.
\paragraph{}
This paragraph explains how the proxy checks the ServerHello of TLS hanshake. After forwarding the ClientHello to the server, a ServerHello will be responded and the proxy will check the final result of the handshake applies to the best practice. If a naughty attacker made the negotiation result unsafe, TLS 1.0 or the cipher suite RSA\_WITH\_NULL\_MD5 for example, the connection will be blocked.

\section{Process view of traffic}
\cref{fig:tls-process-view} shows how a TLS connection interacts with the whole firewall system.
\begin{figure}[H]
  \includegraphics[width=\textheight, angle=90]{graphics/puml/process-tls-traffic.png}
  \caption{Process view of TLS traffic from user}
  \label{fig:tls-process-view}
\end{figure}

\chapter{Plaintext connections and other services}\label{cha:plaintext}

\section{HTTP}
\subsection{Design}
\paragraph{}
Plaintext HTTP connections should be tunneled and encrpte through TLS proxy, if the remote server does not support encrypted connections, the request should fail.
\subsection{Implementation}
\paragraph{}
hood-http-handler.py is the proxy created to filter and protect HTTP plaintext connections. The proxy checks the host name with a known list of OCSP (Online Certificate Status Protocol) and CRL (Certificate Revocation List) servers. Only the connections to those servers are allowed to be plaintext because those connections usually be OCSP over HTTP connections, which have no reason to be protected. The connections to other servers are tunneled via TLS protocol through the hood-tls-proxy service. See \cref{fig:ocsp-process-view,fig:http-process-view}.

\begin{figure}[H]
  \includegraphics[width=\textheight, angle=90]{graphics/puml/process-ocsp-traffic.png}
  \caption{Process view of OCSP over HTTP traffic from user}
  \label{fig:ocsp-process-view}
\end{figure}

\begin{figure}[H]
  \includegraphics[width=\textheight, angle=90]{graphics/puml/process-http-traffic.png}
  \caption{Process view of normal HTTP traffic from user}
  \label{fig:http-process-view}
\end{figure}

\section{Service exposure}
\paragraph{}
Sometimes, using HTTP and HTTPS alone is still not enough, other services need to be accessed from the internal of the firewall. Service exposure is designed to satisfy this requirement.

\subsection{Design}
\paragraph{}
To maximize protection, service exposure supports only exposing services from external to the internal of the firewall. Since the protocol is unknown, the flexiblity of the proxy is limited when comparing to HTTP/TLS proxies because it is impossible for the proxy to extract the host name from handshake packets and many protocols do not include the identification of the remote host in its handshake packets.

\section{Implementation}
\paragraph{}
The service is implemented in a Python script named hood-expose.py.


\chapter{Date time synchornization}\label{cha:time}
\section{Introduction}
\paragraph{}
A correct time is required for TLS protocol to check certificates. Network Time Protocol (NTP) is used by most modern systems to synchronize the clock with a remote server.
\subsection{The issue}
\paragraph{}
A problem with using hardware like a Raspberry Pi is that it does not have a battery to keep the clock ticking after the power source is cut. So a time synchronization mechanism is a must for this firewall.
\paragraph{}
Many operating systems are pre-configured to use an NTP server which has a unique domain name that can be used by a network administrator to identify the operating systems being used by the client.
\paragraph{}
Both the unique port number (UDP 123) and the unique domain names (time.windows.com, time.apple.com, and ubuntu.pool.ntp.org) make NTP a protocol that can be easily identified and targeted. Various attacks can be done to the protocol itself\citep{ntp:attack}. The difference in NTP behavior between different operating systems has been used in OS fingerprinting and tethering detection \citep{osandtether}. Not to mention that the operating system information being exposed by an NTP domain name can also help an attacker target the NTP client being used by the device.

\section{Design}
\paragraph{}
Give up on NTP, use HTTP/HTTPS instead. Use the "Date" header from the response of an HTTP server to synchronize date time with acceptable accuracy. To hide from security detections, the attack vectors targeted to HTTP/HTTPS protocol usually do not want to make mistakes in the header. Even if an attacker targeted the method used by the hood firewall, It's hard to say whether this request is made for time synchronization. Thus the date field of an HTTP response is generally trustworthy.

\section{Implementation}
\paragraph{}
The tool is implemented in a Python script named hood-timesync.py. It accepts two command line arguments as listed in \cref{tab:timesync_cmdarg}. It at first tries to receive an HTTP response through a TLS connection from the domain name specified by the host argument. If it fails, the reason could be the website is down or the system time is too different from the actual time and made a valid certificate unable to pass the validation. Thus, a plaintext connection to the host name provided by the last resort address argument is made as the second attempt. After the second attempt, the tool starts another attempt to receive time from the domain of the host argument via TLS connection, because TLS has less chance to be attacked and because the reason why the first step failed could be the website is temporarily down, the reason could also be the huge time difference made the validation of the certificate failed. In both cases, a HTTPS request to the domain may become possible to succeed after the second attempt. An Epoch time is used as an 'anchor' time. Based on the assumption that time only moves forward, any time before this value will be rejected.

\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|c|c|c|m{68mm}|}
    \hline
    Name               & Type & Default      & Description                                                                                                                                                                                                                                               \\
    \hline
    --host             & str  & www.bing.com & The website to request time from                                                                                                                                                                                                                          \\
    --last-resort-host & str  & 1.1.1.1      & The website used as the last resort, should be an IP address                                                                                                                                                                                              \\
    --time-anchor      & int  & 1703703361   & An Epoch time that being anchored as past.\newline Based on the assumption that time only moves forward, any time before this value will be rejected.\newline Set 0 to disable this test.\newline Example: -\-time-anchor=\$(stat /etc/os-release -c \%W) \\
    \hline
  \end{tabular}
  \caption{Command line arguments of hood-timesync.py}
  \label{tab:timesync_cmdarg}
\end{table}

\chapter{Network activity simulation}\label{cha:simulation}
\section{Introduction}
\paragraph{}
In this chapter, the goal of the firewall changed to leaking fake information instead of preventing the information leakage because the sad truth is that the combination of all efforts on those protocols is not enough when facing a more sophisticated network analysis. For example, the connections to Windows update servers and App Store servers can be used to detect Windows and Apple devices \citep{osandtether}, but the firewall has no reason to stop those connections. Apart from that, the domain name leaked from TLS handshakes can also tell the eavesdroppers what websites a person is viewing and then may infer what the person is doing. Virtual private networks (VPNs) may prevent that information from being captured by local eavesdroppers but VPNs also have an egress, where could have other eavesdroppers. Thus, when visiting internet websites, the leak of information is inevitable.

\section{Design}
\paragraph{}
A service to simulate different network activities is designed to solve this issue. The goal is to hide user network activities inside the flood of fake network activities to increase the difficulty of an analyzer to produce useful reports. However, the risk of using this service is to produce a false alarm immediately and make the user blocked for tethering, make the user fired for browsing unrelated websites, etc. To prevent the firewall from being compromised by browser vulnerabilities, browser-based simulation tools, like Puppeteer (see \cref{sec:Puppeteer}), should not be used for implementation. It should also make plaintext traffic to attract attention from attackers and eavesdroppers to make them less focused on the actual user traffic.

\section{Implementation}
\paragraph{}
The service is implemented in a Python script named hood-actor.py. It can parse and execute action files. To simulate the behaviors of a human user or a computer service. All implementations inside the script are based on the base modules of Python, to avoid the version management of third-party libraries being involved in the installation process of the firewall.

\subsection{Action files}
\paragraph{}
Action files are in JSON format. An action file contains an array of objects. All objects in the array have a "type" field to let the parser know how to process it. Supported object types are descripted in \cref{tab:action_type,tab:properties_object,tab:task_object}.

\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|}
    \hline
    Value      & Description                    \\
    \hline
    properties & Properties of the action       \\
    task       & Tasks to be done in the action \\
    \hline
  \end{tabular}
  \caption{"type" field of action file objects}
  \label{tab:action_type}
\end{table}


\begin{table}[H]
  \centering
  \begin{tabular}{|c|c|c|}
    \hline
    Field       & Type                           & Description                     \\
    \hline
    type        & string                         & "properties"                    \\
    safe\_age   & integer                        & Minimum age safe to do this     \\
    proper\_age & list of two numbers [min, max] & Proper range of age to do this. \\
    \hline
  \end{tabular}
  \caption{"properties" object of action file}
  \label{tab:properties_object}
\end{table}

\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|p{34mm}|p{26mm}|p{65mm}|}
    \hline
    Field                   & Type                           & Description                                          \\
    \hline
    type                    & string                         & "task"                                               \\
    name                    & string                         & Name of the task, must be unique in current file     \\
    before                  & list of strings                & Names of tasks that should run no earlier than this. \\
    after                   & list of strings                & Names of tasks that should run before this.          \\
    delay\_between\_actions & list of two numbers [min, max] & Range of seconds to wait between actions.            \\
    actions                 & list of strings                & list hood action script                              \\
    \hline
  \end{tabular}
  \caption{"task" object of action file}
  \label{tab:task_object}
\end{table}

\subsection{HoodExecutor}
\paragraph{}
HoodExecutor is a general-purpose multi-thread task executor written in Python. It is part of hood-actor.py It can run and schedule in parallel tasks that have dependency relationships and delay requirements. It has a thread pool of workers to execute tasks and a single thread for scheduling delayed tasks. It is required to simulate the paralleled requests sent out from real-world browsers without a third-party HTTP client based on asyncio. It is also the cornerstone of fulfilling all the execution requirements of the tasks and actions in an action file.

\subsection{Browser}\label{sec:browser}
\paragraph{}
A fake browser is created to simulate network activities of browsing. It records the cookies specified in the HTTP response headers and sends them out like a real browser. It parses the HTML content of the webpage to extract the resources to be loaded and load them in parallel just like a real browser. It uses headers that are used by real browsers and uses different headers on different resources just like a real browser. Cookies are stored in memory and used in the running session. However, due to security concerns, and also to reduce the performance impacts caused by the actor, the fake browser will neither render the webpage nor evaluate scripts used by the webpage. The reasons are discussed in \cref{cha:events}.

\subsection{Hood action script}
\paragraph{}
A hood action script is a script to describe actions to be done to the actor. Each line of the script can be seen as three parts: namespaces, commands, and arguments. For example, \newline "hood:browser:goto:http://www.example.com". "hood:browser:" is to refer browser namespace from the hood namespace, "goto" is a command inside the browser namespace to tell the interpreter to use the browser to load a webpage. "http://www.example.com" is the parameter of the "goto" command. In this example, it represents the URL of the webpage to be loaded.
\subsubsection{hood:browser:goto command}
\paragraph{}
Its usage is "hood:browser:goto URL". Its effect is to use a fake browser (See \cref{sec:browser}) to load a URL. When the special value "random\_link" is used as the argument, the actor randomly picks a link from current webpage of the browser to go to, but nothing will be done if the current webpage contains no links.
\subsubsection{hood:loop command}
\paragraph{}
Its usage is "hood:loop:CONDITION:COMMAND". It is used to declare a loop. Multiple conditions can be declared in the CONDITION part by syntax "key=value[,key=value]". Currently, only two types of conditions are implemented: "exit\_chance" and "delay". "exit\_chance" describes the chance of the loop to be stopped. "exit\_chance=0.33" means the loop has a 33\% chance of termination at the beginning of each loop, "0" means it will never have an end. "1" means the loop will never be executed. "delay" describes the range of delay between each loop. "delay=0-2.5" means the delay between each loop is from 0 seconds to 2.5 seconds. A Just-In-Time compiler is implemented to convert the CONDITION field into Python code. The COMMAND part is the hood action script to be executed in the loop.

\subsection{Hood action script}
\paragraph{}
\cref{fig:actor-logic-view} is the logical view of the hood-actor.py, it shows the calling relationship between different components.
\begin{figure}[H]
  \includegraphics[width=0.9\textwidth]{graphics/puml/actor.png}
  \caption{Logical view of hood-actor.py}
  \label{fig:actor-logic-view}
\end{figure}

\chapter{Dispatcher and firewall rules}\label{cha:dispatcher}
\paragraph{}
Dispatcher is a shell script named 02-hood-dispatcher. It interacts with the changes in the network status or the system status to dynamically configure firewall rules and to start or stop network services. Its callers are three systemctl services: before-network.service (See \cref{sec:before-network-service}), udev.service, and NetworkManager-dispatcher.service.

\section{Initial state of firewall rules}
\paragraph{}
The initial state of firewall rules (See \cref{sec:nftables.conf}) is basic because the design of nftables made the rules with interface name involved requires to be done dynamically. It only allows IPv4 and ARP protocol at layer 3. It allows anything to lo interface but rejects anything else to communicate from 127.0.0.1 or to 127.0.0.1. It allows UDP/TCP packets in connection track established and related state. It allows the device to send or receive ICMP fragmentation-needed packets. Anything else is ignored.

\section{On udev add event}
\subsubsection{netdev filter}
\paragraph{}
A default netdev filter will be added to both LAN and WAN interfaces. It has to be added dynamically because both its ingress and egress filters require the name of the device. The filter accepts only ARP and IP packets to pass through. The firewall rules from other places already achieved the same thing but it is added because it is the earliest place to filter out a packet and the earlier a packet is filtered the less chance the packet to cause a problem.

\section{On system startup}
\paragraph{}
Upon system startup, the dispatcher will be called by before-network.service. It will start two dmesg instances one is for redirecting firewall-related logs to a log file another is for formatting the log to a more human-readable form. In the iptables era, it was used for initializing iptables rules.
\paragraph{}
Since the udev event could be triggered at a very early stage of the startup, so early that the nftables service may not be available, and adding rules may fail. The dispatcher tries to add a netdev filter on all available network instances again because the timing before-network.service is sufficient to ensure the availability of nftables.service.

\section{On NetworkManager-dispatcher pre-up event}
\paragraph{}
This event means that a network interface is connected to the network but is not yet fully activated. The dispatcher checks the device path with the device specified during the installation process to know whether it is a WAN port. The device path is the real path of the network device. For example, on Linux, the device path of eth0 is the result of "realpath /sys/class/net/eth0".
\subsubsection{WAN port}
\paragraph{}
For the WAN port network interface, the dispatcher allows UDP packets to be sent out from the local 68 port to the remote 67 port and to be received from the remote 67 port to the local 68 port for DHCP protocol.
\subsubsection{LAN port}
\paragraph{}
For LAN port network interfaces, the dispatcher at first picks a randomized start number \(\in [2, 255]\) as the third byte of the IPv4 address, and all following LAN ports use the result of \[2 + (Last Used Number - 1) \mod 254\] as the third byte. The randomization of the start number is made after each system starts. LAN subnet randomization could help increase the difficulty of malicious code in detecting the firewall from the LAN port.
\paragraph{}
After randomization, the following firewall rules are added:
\begin{table}[H]
  \begin{itemize}
    \item Accept the incoming TCP connections through the LAN interface if the destination IP address is the LAN IP address and the destination port is 80 or 443. For hood-http-handler.py and hood-tls-proxy
    \item Accept the incoming UDP packets through the LAN interface if the destination IP address is the LAN IP address and the destination port is 53. For the dnsmasq instance.
    \item Allow UDP packets to be sent out from the local 67 port to the remote 68 port and to be received from the remote 68 port to the local 67 port. For the dnsmasq instance.
  \end{itemize}
  \caption{Firewall rules to be added for LAN ports}
  \label{lst:LAN-rules}
\end{table}
\paragraph{}
A dnsmasq instance is started for this network interface, to assign IP addresses to connected devices, to let connected devices use the IP address of the LAN port of the firewall as the DNS server, and to respond to the IP address of the firewall LAN port for DNS requests.

\section{On NetworkManager-dispatcher up event}
\paragraph{}
The dispatcher only reacts to this event for the WAN port. It at first waits for DHCP to finish. After DHCP is done, the dispatcher removes DHCP related accept rules from nftables and adds a rule to accept outbound TCP connections from the WAN instance with the source address as the DHCP result to remote 80 and 443 ports. This rule is for HTTP and HTTPS protocols. After that, the dispatcher restarts the hood-network-services.service (\cref{sec:hood-network-services.service}). It will also check the existence of /do\_upgrade or /run\_once files to do a system upgrade or to run the script.

\section{On NetworkManager-dispatcher down event}
\paragraph{}
The dispatcher removes the firewall rules dynamically added for this instance and kills the dnsmasq instances for this interface.

\chapter{Installation}\label{cha:install}
\paragraph{}
Installation now can only be done from Linux. install.sh is the shell script that is in charge of the installation process. It copies and applies the scripts, executables, and configuration files to the target Raspberry Pi OS filesystem. It accepts the command line arguments listed in \cref{tab:install_arg}.

\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|m{27mm}|m{30mm}|m{68mm}|}
    \hline
    Name                              & Default           & Description                                                                                                               \\
    \hline
    usb\_tether=                      & 1                 & Share network to computer via USB cable                                                                                   \\
    harden\_only=                     & 0                 & Only apply hardening parts. Let the target SBC can still used as a computer.                                              \\
    disable\_wireless=                & 1                 & Disable WiFi and Bluetooth.                                                                                               \\
    disable\_gpu=                     & 1                 & Disable GPU.                                                                                                              \\
    target=                           & /                 & The target root/device to install firewall.                                                                               \\
    wan\_port\_\newline device\_path= & auto-built-in-eth & The path of the device to be used as WAN port.\newline auto-built-in-eth means find built-in Ethernet port automatically. \\
    \hline
  \end{tabular}
  \caption{Command line arguments of install.sh}
  \label{tab:install_arg}
\end{table}

\section{Checking target system}
\paragraph{}
Multiple checks to the target path are done before the beginning of the installation process to avoid potential harm to the user's computer when a wrong path is used. It first checks the type of the target, if the target path is not a directory target will be treated as a device or file and will be mounted as the pattern of a live system of Raspberry Pi OS. If the target is a file, then the target will be mounted as a disk image. If the target does not exist, "/dev/" prefix will be added and will be treated as a name of a device. Then if the content of /boot/firmware/config.txt of the target does not contain the string "dtparam", the target will not be treated as a Raspberry Pi OS filesystem and the installation process will be aborted.

\section{Disable wireless}
\paragraph{}
Multiple methods are used to ensure the complete disablement of wireless devices. See \cref{tab:config_disable_wireless,tab:delete_disable_wireless}.

\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|m{57mm}|m{68mm}|}
    \hline
    Configuration file                                    & Contents added                                                                                                                                                                                                     \\
    \hline
    boot/firmware/config.txt                              & dtoverlay=disable-bt\newline dtoverlay=disable-wifi                                                                                                                                                                \\
    /etc/modprobe.d/bin-y-disable-wireless-blacklist.conf & blacklist bluetooth\newline blacklist btbcm\newline blacklist hci\_uart\newline blacklist i2c\_brcmstb\newline blacklist i2c\_dev\newline blacklist brcmfmac\newline blacklist brcmutil\newline blacklist cfg80211 \\
    \hline
  \end{tabular}
  \caption{Configurations added to target to disable wireless}
  \label{tab:config_disable_wireless}
\end{table}

\begin{table}[H]
  \begin{itemize}
    \item /lib/firmware/brcm/*
    \item find /lib/linux-image*/broadcom -type f
    \item find /usr/lib/modules/ -name bluetooth
  \end{itemize}
  \caption{Files deleted from target to disable wireless}
  \label{tab:delete_disable_wireless}
\end{table}

\section{Disable GPU}
\paragraph{}
Multiple methods are used to ensure the complete disablement of GPU. See \cref{tab:config_disable_gpu,tab:delete_disable_gpu}.

\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|m{57mm}|m{68mm}|}
    \hline
    Configuration file                               & Contents modified                                                                                    \\
    \hline
    boot/firmware/config.txt                         & Removed:\newline dtoverlay=vc4-kms-v3d\newline dtoverlay=vc4-fkms-v3d                                \\
    /etc/modprobe.d/bin-y-disable-gpu-blacklist.conf & Added:\newline blacklist v3d\newline blacklist drm\newline blacklist drm\_panel\_orientation\_quirks \\
    \hline
  \end{tabular}
  \caption{Configurations modified to target to disable GPU}
  \label{tab:config_disable_gpu}
\end{table}

\begin{table}[H]
  \begin{itemize}
    \item Any directory under /usr/lib/modules/ with the name "gpu"
  \end{itemize}
  \caption{Files deleted from target to disable GPU}
  \label{tab:delete_disable_gpu}
\end{table}

\begin{landscape}
  \section{Other configurations modified}
  \begin{table}[H]
    \rowcolors{2}{tablegray}{}
    \begin{tabular}{|p{70mm}|p{40mm}|p{80mm}|}
      \hline
      Configuration file                                                                       & Contents modified                                                                                                   & Purpose                                                                            \\
      \hline
      /boot/firmware/cmdline.txt                                                               & Added:\newline ipv6.disable=1\newline apparmor=1\newline security=apparmor                                          & disable IPv6\newline enable AppArmor                                               \\
      /etc/modprobe.d/bin-y-blacklist.conf                                                     & Added:\newline blacklist ipv6\newline blacklist hci\_uart\newline blacklist i2c\_brcmstb\newline blacklist i2c\_dev & disable IPv6, i2c, and UART                                                        \\
      /boot/firmware/config.txt                                                                & Added:\newline enable\_uart=0                                                                                       & disable UART                                                                       \\
      /etc/nftables.conf                                                                       & See \cref{sec:nftables.conf}                                                                                        & nftables rules                                                                     \\
      /etc/hosts                                                                               & OMITTED                                                                                                             & provide address of some DNS services                                               \\
      /etc/sysctl.conf                                                                         & OMITTED                                                                                                             & sysctl related hardening                                                           \\
      /etc/rc.local                                                                            & OMITTED                                                                                                             & host name randomization                                                            \\
      /etc/pki/nssdb/cert9.db\newline /etc/pki/nssdb/key4.db\newline /etc/ca-certificates.conf & OMITTED                                                                                                             & manage trusted certificates                                                        \\
      /etc/NetworkManager/NetworkManager.conf                                                  & OMITTED                                                                                                             & MAC address randomization                                                          \\
      /etc/apt/sources.list\newline /etc/apt/sources.list.d/raspi.list                         & OMITTED                                                                                                             & use HTTPS mirrors for apt                                                          \\
      files related to systemd services                                                        & OMITTED                                                                                                             & enable hood services, enable required system services, and disable unsafe services \\
      \hline
    \end{tabular}
    \caption{Configurations modified to target to disable GPU}
    \label{tab:other_config}
  \end{table}
\end{landscape}


\chapter{Showing network activities}\label{cha:show}
\paragraph{}
Network activities of the firewall system are logged to multiple places by multiple services (see \cref{tab:network_log}). All logs are simplified to human-readable forms and aggregated to a tty device to let users access them easily. If the firewall was installed with the parameter harden\_only=1, aggregated logs will be sent to tty8, and if the installation parameter harden\_only was 0, aggregated logs will be sent to tty1.
\begin{table}[H]
  \centering
  \rowcolors{2}{tablegray}{}
  \begin{tabular}{|c|c|}
    \hline
    Service              & Log location                   \\
    \hline
    hood-name-service.py & /var/log/hood-name-service.log \\
    hood-http-handler.py & /var/log/hood-http-handler.log \\
    hood-tls-proxy       & /var/log/hood-tls-proxy.log    \\
    hood-dispatcher      & /var/log/hood-dispatcher.log   \\
    nftables             & dmesg                          \\
    \hline
  \end{tabular}
  \caption{Log locations of network services.}
  \label{tab:network_log}
\end{table}



\chapter{Analyzation to security events}\label{cha:events}
\paragraph{}
This chapter analyzes security events and provides reasons why many things that could bring convenience are disabled in the firewall. Related data can be found from project GitHub repository \citep{hood:github}.

\section{Security releases and updates}
\begin{figure}[H]
  \includegraphics[width=\textwidth]{data/apple_security_releases/result.png}
  \caption{Top 19 mostly mentioned components in Apple security releases\newline from January 8th, 2020 to January 12th, 2024}
  \label{fig:apple-sec-release}
\end{figure}
\paragraph{}
Texts of Apple security releases of its operating systems between January 8th, 2020 and January 12th, 2024 are collected and the number of times of their components being mentioned are counted. See \cref{fig:apple-sec-release}. They are the top 19 mostly mentioned components with one exception: the number of "Wi-Fi + Bluetooth" is the sum of the two.
\paragraph{}
The result explains how risky using a browser could be: WebKit, the underlying engine of Safari is the top 1 on the list, the browser Safari itself is the 9th place, and many things related to browsing are on the list: ImageIO, FontParser, CoreText, and WebRTC. Without the time spent on creating a 'fake' browser, the simulation of web-browsing network activity may have to choose between crude bash scripts or risky browser-based tools.
\paragraph{}
It also demonstrates why firewall disables wireless by default: Both "Wi-Fi" and "Bluetooth" are on the list, and their sum can take the fourth place.
\begin{figure}[H]
  \includegraphics[width=\textwidth]{data/fedora_39_security_updates/result.png}
  \caption{Top 20 mostly mentioned package name prefixes in Fedora 39 security updates\newline from Feburary 14th, 2020 to January 10th, 2024\newline "python3.11" listed in the chart is not part of top 20}
  \label{fig:fedora-sec-update}
\end{figure}
\paragraph{}
Package names of Fedora 39 security updates between February 14th, 2020 and January 10th, 2024 are collected, and the number of times of prefixes was mentioned are counted. See \cref{fig:fedora-sec-update}. The data is not complete because only the titles of the links are collected and some titles omitted some packages like "a, b, c \& X more". In this case, the "X more" is not counted. There are 18 records contains "X more" within 285 records, but the result can still spit out some truth because the more frequently a component causes a security update, the less the times of being published with a lot of other packages contributes to the total. The result also proves the high risk of browsers: both "firefox and "chromium" are in the top 10. The result also seemingly indicates the high risk of Python as "python" is 1st place, which renders the use of Python as a mistake, but the "python" prefix is shared by both the packages of multiple Python versions and the packages of different Python libraries. To evaluate the true risk of using Python, as the firewall only uses one Python version and only uses built-in modules, the prefix "python3.11" was counted additionally and the result was only twice.
\section{IPv6}
\paragraph{}
This section explains why firewall disables IPv6 by default. I searched both the keyword "IPv6" and the keyword "IPv4" from the website \url{https://cve.mitre.org}. On Jan 14th, 2024 (UTC +1) 00:00, there are 615 CVE records that match the keyword "IPv6" and 360 CVE records that match the keyword "IPv4". From 2022, there are 81 results match the keyword "IPv6" and 36 result match the keyword "IPv4". Those numbers indicate that the overall implementations of IPv6 is less stable than of IPv4. It could be explained as IPv4 implementations have a longer history of bug fixes.

\section{GPU}
\paragraph{}
One of the reasons to disable GPU is a stealthy GPU-based keylogger reported on EUROSEC 2013. \citep{gpu:keylogger}

\section{Conclusions}
\paragraph{}
As conclusion, most of decisions on disabling things are based on the analyzation of differnt security events and supported by numbers and related threats.

\chapter{Penetration test}\label{cha:test}
\paragraph{}
To be close to real-world application of this tool, a computer from the university classroom and my iPhone are used to test the firewall. The computer has remote management tools pre-installed and I do not have the administrator permissions to configure the computer or to install some protection tools. Thus, without the help from the firewall, there is very little I can do. Experiment data can be found from project GitHub repository \citep{hood:github}.

\section{Man-in-the-middle (MITM) attack, DNS hijacking, and IP hijacking}
\subsection{Experiment tools}
\paragraph{}
Following devices are used in the experiment: Two computers running live Parrot OS from Parrot-htb-6.0\_amd64.iso. A Raspberry Pi 4B running hood firewall installed with the parameter "harden\_only=1" to 2023-12-05-raspios-bookworm-arm64.img.xz.

\subsection{Experiment steps}
\paragraph{}
Computer 1 plays the role of internet provider and the role of certificate authority. Computer 2 plays the role of victim.

\subsubsection{Create shared network}
\paragraph{}
At first, enable network sharing on Computer 1 with following commands, and connect two computers via Ethernet ports.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
- Computer 1, Terminal 1
> nmcli device set eno1 managed no
> sudo ip address add dev eno1 192.168.22.1
> sudo ip route add 192.168.22.0/24 dev eno1 src 192.168.22.1
> sudo sysctl -w net.ipv4.ip_unprivileged_port_start=0
> sudo sysctl -w net.ipv4.ip_forward=1
> sudo nft add table ip filter
> sudo nft add chain ip filter forward { type filter hook forward priority filter\; policy drop\; }
> sudo nft add rule ip filter forward ip saddr 192.168.22.0/24 iif eno1 oif wlp2s0 accept
> sudo nft add rule ip filter forward ct state {established, related} accept
> sudo nft add rule ip filter forward log prefix "Dropped " flags all drop
> sudo nft add table ip nat
> sudo nft add chain ip nat postrouting { type nat hook postrouting priority srcnat\; policy accept\; }
> sudo nft add rule ip nat postrouting ip saddr 192.168.22.0/24 ip daddr != 192.168.22.0/24 iif eno1 oif wlp2s0 masquerade
> sudo /usr/sbin/dnsmasq --conf-file=/dev/null --no-hosts --no-resolv --keep-in-foreground --interface=eno1 --except-interface=lo --clear-on-reload --strict-order --listen-address=192.168.22.1 --bind-interfaces --no-poll --server=1.1.1.1  --cache-size=0  --dhcp-range=192.168.22.1,192.168.22.255,255.255.255.0,400w --dhcp-authoritative --dhcp-leasefile=/tmp/yongbin.lease --dhcp-option=option:dns-server,192.168.22.1 --dhcp-option=3,192.168.22.1 --log-queries --log-facility=-
\end{lstlisting}

\subsubsection{Without attack and protection}
\paragraph{}
The following records show what happens without MITM attack: the text posted successfully and looks the same to both computers.

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
# post text without MITM attack
- Computer 2, Terminal 1
> echo "Thank you very much for the feedback. Your suggestion on X sounds legit. I will make X able to Y after I finished Z. I will send you another email once I finished related tasks." | curl -sS -F 'sprunge=<-' https://sprunge.us
http://sprunge.us/yqnNHp
> curl https://sprunge.us/yqnNHp
Thank you very much for the feedback. Your suggestion on X sounds legit. I will make X able to Y after I finished Z. I will send you another email once I finished related tasks.
- Computer 1, Terminal 2
> curl https://sprunge.us/yqnNHp
Thank you very much for the feedback. Your suggestion on X sounds legit. I will make X able to Y after I finished Z. I will send you another email once I finished related tasks.
# everything is correct
\end{lstlisting}

\subsubsection{With MITM attack by DNS hijacking, without protection}
\paragraph{}
Following commands are used to prepare MITM attack by DNS hijacking. The script used by mitmproxy is available at \cref{sec:mitmattack.py}.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
- Computer 1, Terminal 2
> sudo kill $(ps -ef |grep dnsmasq|grep yongbin -m 1|sed "s/\w* *//"|cut -d " " -s -f 1)
> sudo /usr/sbin/dnsmasq --conf-file=/dev/null --no-hosts --no-resolv --keep-in-foreground --interface=eno1 --except-interface=lo --clear-on-reload --strict-order --listen-address=192.168.22.1 --bind-interfaces --no-poll --address=/#/192.168.22.1  --cache-size=0  --dhcp-range=192.168.22.1,192.168.22.255,255.255.255.0,400w --dhcp-authoritative --dhcp-leasefile=/tmp/yongbin.lease --dhcp-option=option:dns-server,192.168.22.1 --dhcp-option=3,192.168.22.1 --log-queries --log-facility=-

- Computer 1, Terminal 1
> mitmproxy --listen-port 443 --listen-host 192.168.22.1 -s mitmattack.py

- Computer 1, Terminal 3
> python3 -m http.server -d ~/.mitmproxy/

- Computer 2, Terminal 1
> wget 192.168.22.1/mitmproxy-ca-cert.pem

- Computer 1, Terminal 3
> ^C
\end{lstlisting}

\paragraph{}
Following records show what happened under attack: The posted text looks correct to the victim but looks different to other person.

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
# post text when CA is doing MITM attack, without hood
- Computer 2, Terminal 1
> echo "Thank you very much for the feedback. Your suggestion on X sounds legit. I will make X able to Y after I finished Z. I will send you another email once I finished related tasks." | curl -sS --cacert mitmproxy-ca-cert.pem -F 'sprunge=<-' https://sprunge.us
http://sprunge.us/ARbKPO
> curl -sS --cacert mitmproxy-ca-cert.pem https://sprunge.us/ARbKPO
Thank you very much for the feedback. Your suggestion on X sounds legit. I will make X able to Y after I finished Z. I will send you another email once I finished related tasks.
# The result looks correct to the victim
- Computer 1, Terminal 3
> curl https://sprunge.us/ARbKPO
Who do you think you are? How dare you to give me suggestions like this? Your naive ideas will never work. You have been blocked. *NEVER* send me emails again.
# However, the result looks different to other person
\end{lstlisting}

\subsubsection{With MITM attack by DNS hijacking, with "hood" protection}
\paragraph{}
Next, test what happens to the victim with "hood" firewall. Steps are following. 1. Connect Raspberry Pi to computer by USB cable 2. Disconnect the Ethernet cable from computer 2 and connect it to Raspberry Pi. 3. Use following commands to give direct access to other websites but still attacking the website sprunge.us.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
- Computer 1, Terminal 3
> sudo kill $(ps -ef |grep dnsmasq|grep yongbin -m 1|sed "s/\w* *//"|cut -d " " -s -f 1)
> sudo /usr/sbin/dnsmasq --conf-file=/dev/null --no-hosts --no-resolv --keep-in-foreground --interface=eno1 --except-interface=lo --clear-on-reload --strict-order --listen-address=192.168.22.1 --bind-interfaces --no-poll --address=/sprunge.us/192.168.22.1 --server=1.1.1.1 --cache-size=0  --dhcp-range=192.168.22.1,192.168.22.255,255.255.255.0,400w --dhcp-authoritative --dhcp-leasefile=/tmp/yongbin.lease --dhcp-option=option:dns-server,192.168.22.1 --dhcp-option=3,192.168.22.1 --log-queries --log-facility=-
\end{lstlisting}

\paragraph{}
Following records show what happened: The victim bypassed the attack.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
# Computer 2 starts to use hood firewall
- Computer 2, Terminal 1
> curl https://sprunge.us/ARbKPO
Who do you think you are? How dare you to give me suggestions like this? Your naive ideas will never work. You have been blocked. *NEVER* send me emails again.
# DNS redirect attack stopped working
\end{lstlisting}

\subsubsection{With MITM attack by IP hijacking, with "hood" protection}
\paragraph{}
In this section, the attacker used IP hijacking to achieve MITM attack. Computer 1 used following commands to conduct IP hijacking.

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
# Computer 1 starts to use more advanced method to achieve MITM
- Computer 1, Terminal 2
> sudo nft add chain ip nat prerouting { type nat hook prerouting priority dstnat\; policy accept\; }
> sudo nft add rule nat prerouting ip saddr 192.168.22.0/24 ip daddr {$(dig +short sprunge.us|tr "\n" ",")} iif eno1 dnat to 192.168.22.1
\end{lstlisting}

\paragraph{}
The same command starts to show error on the victim's computer.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
- Computer 2, Terminal 1
> curl --cacert mitmproxy-ca-cert.pem https://sprunge.us/ARbKPO
curl: (35) OpenSSL SSL_connect: SSL_ERROR_SYSCALL in connection to sprunge.us:443
\end{lstlisting}

\paragraph{}
The output of the "hood" firewall shows to the victim that something is wrong with the certificate.

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
# output from hood firewall:
DNS query 'sprunge.us'
 verifying sprunge.us 172.67.195.185 :/CN=sprunge.us
sprunge.us handshake failed: certificate verify failed (SSL routines)
 verifying sprunge.us 104.21.84.187 :/CN=sprunge.us
sprunge.us handshake failed: certificate verify failed (SSL routines)
No endpoints sprunge.us
\end{lstlisting}

\subsection{Conclusions}
\paragraph{}
The experiment records show that the "hood" firewall can help a victim to bypass simple DNS hijacking couducted by network providers, the "hood" firewall could not protect the victim from IP hijacking but if the attacker wants to decrypt the TLS connection, even if the root certificate has been trusted by the victims computer, the "hood" firewall can still alert the victim and block the connection. However, without this firewall, the victim of the attacks could see nothing while using software tools normally.

\section{Information gathering by metasploit}
\subsection{Experiment tools}
\paragraph{}
Following devices are used in the experiment: A computer running live Kali Linux from kali-linux-2024-W03-live-amd64.iso. A Raspberry Pi 4B running 'hood' firewall installed with the parameter "harden\_only=1" to 2023-12-05-raspios-bookworm-arm64.img.xz. A computer in the university classroom.

\subsection{Information gathering from university computer}
\paragraph{}
The following are selected commands and outputs, full records are availible from project GitHub repository \citep{hood:github}:

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
db_nmap -Pn -A 10.10.6.64
[*] Nmap: Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-20 23:20 UTC
[*] Nmap: Nmap scan report for USILU-3325.usilu.net (10.10.6.64)
[*] Nmap: Host is up (0.00047s latency).
[*] Nmap: Not shown: 996 filtered tcp ports (no-response)
[*] Nmap: PORT     STATE SERVICE       VERSION
[*] Nmap: 135/tcp  open  msrpc         Microsoft Windows RPC
[*] Nmap: 139/tcp  open  netbios-ssn   Microsoft Windows netbios-ssn
[*] Nmap: 445/tcp  open  microsoft-ds?
[*] Nmap: 3389/tcp open  ms-wbt-server Microsoft Terminal Services
[*] Nmap: | ssl-cert: Subject: commonName=USILU-3325.usilu.net
[*] Nmap: | Not valid before: 2023-11-22T23:00:22
[*] Nmap: |_Not valid after:  2024-05-23T23:00:22
[*] Nmap: | rdp-ntlm-info:
[*] Nmap: |   Target_Name: CAMPUS
[*] Nmap: |   NetBIOS_Domain_Name: CAMPUS
[*] Nmap: |   NetBIOS_Computer_Name: USILU-3325
[*] Nmap: |   DNS_Domain_Name: usilu.net
[*] Nmap: |   DNS_Computer_Name: USILU-3325.usilu.net
[*] Nmap: |   DNS_Tree_Name: usilu.net
[*] Nmap: |   Product_Version: 10.0.19041
[*] Nmap: |_  System_Time: 2024-01-20T22:20:28+00:00
[*] Nmap: |_ssl-date: 2024-01-20T22:21:11+00:00; -1h00m00s from scanner time.
[*] Nmap: Service Info: OS: Windows; CPE: cpe:/o:microsoft:windows
[*] Nmap: Host script results:
[*] Nmap: |_clock-skew: mean: -1h00m00s, deviation: 0s, median: -1h00m00s
[*] Nmap: | smb2-time:
[*] Nmap: |   date: 2024-01-20T22:20:28
[*] Nmap: |_  start_date: N/A
[*] Nmap: | smb2-security-mode:
[*] Nmap: |   3:1:1:
[*] Nmap: |_    Message signing enabled but not required
[*] Nmap: |_nbstat: NetBIOS name: USILU-3325, NetBIOS user: <unknown>, NetBIOS MAC: 5c:f9:dd:e0:97:34 (Dell)
[*] Nmap: Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 60.28 seconds

msf6 auxiliary(scanner/smb/smb_version) > run

[*] 10.10.6.64:445        - SMB Detected (versions:2, 3) (preferred dialect:SMB 3.1.1) (compression capabilities:LZNT1) (encryption capabilities:AES-128-GCM) (signatures:optional) (guid:{a77b41a6-e4e1-4033-8b65-bc9f0b5ff320}) (authentication domain:CAMPUS)
[*] 10.10.6.64:           - Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed

msf6 auxiliary(scanner/rdp/rdp_scanner) > run

[*] 10.10.6.64:3389       - Detected RDP on 10.10.6.64:3389       (name:USILU-3325) (domain:CAMPUS) (domain_fqdn:usilu.net) (server_fqdn:USILU-3325.usilu.net) (os_version:10.0.19041) (Requires NLA: Yes)
[*] 10.10.6.64:3389       - Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed

msf6 auxiliary(scanner/rdp/ms12_020_check) > check

[-] 10.10.6.64:3389       - Auxiliary failed: Errno::ECONNRESET Connection reset by peer
[-] 10.10.6.64:3389       - Call stack:
[-] 10.10.6.64:3389       -   /usr/lib/ruby/3.1.0/socket.rb:452:in `__read_nonblock'
[-] 10.10.6.64:3389       -   /usr/lib/ruby/3.1.0/socket.rb:452:in `read_nonblock'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/vendor/bundle/ruby/3.1.0/gems/rex-core-0.1.31/lib/rex/io/stream.rb:91:in `block in read'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/vendor/bundle/ruby/3.1.0/gems/rex-core-0.1.31/lib/rex/io/stream.rb:336:in `synchronize_access'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/vendor/bundle/ruby/3.1.0/gems/rex-core-0.1.31/lib/rex/io/stream.rb:89:in `read'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/vendor/bundle/ruby/3.1.0/gems/rex-core-0.1.31/lib/rex/io/stream.rb:223:in `get_once'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/ms12_020_check.rb:48:in `check_rdp'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/ms12_020_check.rb:127:in `check_rdp_vuln'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/modules/auxiliary/scanner/rdp/ms12_020_check.rb:174:in `check_host'
[-] 10.10.6.64:3389       -   /usr/share/metasploit-framework/lib/msf/core/auxiliary/scanner.rb:41:in `check'
[-] 10.10.6.64:3389 - Check failed: The state could not be determined.

msf6 auxiliary(scanner/rdp/cve_2019_0708_bluekeep) > check
[*] 10.10.6.64:3389 - The target is not exploitable.

arp -a 10.10.6.64
[*] exec: arp -a 10.10.6.64

USILU-3325.usilu.net (10.10.6.64) at 5c:f9:dd:e0:97:34 [ether] on eth0

msf6 auxiliary(scanner/dcerpc/tcp_dcerpc_auditor) > run

10.10.6.64 - UUID 99fcfec4-5260-101b-bbcb-00aa0021347a 0.0 OPEN VIA 135 ACCESS GRANTED 00000000000000000000000000000000000000000000000005000000
[*] 10.10.6.64:135        - Scanned 1 of 1 hosts (100% complete)
[*] Auxiliary module execution completed
\end{lstlisting}
\paragraph{}
The experiment used only free tools from Kali Linux but still collected a lot of information about the computer: It's manufacturer, operating system, system version, clock skew, domain, host name, time. This shows the necessity of using a firewall.

\subsection{Information gathering from iOS}
\paragraph{}
Following materials are used in the experiment: A computer running live Kali Linux from kali-linux-2024-W03-live-amd64.iso. An iPhone.
\paragraph{}
The prepare steps are following. First, boot the computer into Kali Linux live environment. Then enable tethering on iPhone and connect it to the computer. Then press the "Trust" button on the confirmation dialog. Then use following command from metasploit framework.
\paragraph{}
It shows that iOS devices could be identified by their uniuqe opened port numbers: 49152 and 62078.

\subsection{Information gathering from "hood" firewall}
The following are selected commands and outputs, full records are availible from project GitHub repository \citep{hood:github}:

\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
db_nmap -Pn -A 10.42.0.171
[*] Nmap: Starting Nmap 7.94SVN ( https://nmap.org ) at 2024-01-22 22:40 UTC
[*] Nmap: Nmap scan report for 10.42.0.171
[*] Nmap: Host is up.
[*] Nmap: All 1000 scanned ports on 10.42.0.171 are in ignored states.
[*] Nmap: Not shown: 1000 filtered tcp ports (no-response)
[*] Nmap: Service detection performed. Please report any incorrect results at https://nmap.org/submit/ .
[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 206.84 seconds
\end{lstlisting}
\paragraph{}
No useful information collected from the firewall, it indicates the success of protection.

\section{Eavesdropping}

\subsection{Experiment tools}
\paragraph{}
Following tools are used in the experiment: A computer running live Kali Linux from kali-linux-2024-W03-live-amd64.iso. A Raspberry Pi 4B running the 'hood' firewall installed with the parameter "harden\_only=1" to 2023-12-05-raspios-bookworm-arm64.img.xz. An Ethernet cable. A smartphone.

\subsection{Experiment steps}
\paragraph{}
Two environments were used to check the protection of "hood" firewall against evaesdropping.
\paragraph{}
First, check what network packetscan be captured by eavesdroppers under the protection of "hood" firewall. The experiment steps on eavesdropping attack are following. First, connect the computer to internet shared by the smartphone. Then create a shared network on the network interface of the Ethernet port (Advanced Network Configuration -> Wired connection 1 -> IPv4 Settings Method Shared to other computers, IPv6 Settings disabled). Then, use Wireshark to capture on the interface of the shared network. Then use the cable connect the Ethernet port of the Raspberry Pi to the Ethernet port of the computer. Then, execute the command "curl example.com" on Raspberry Pi.
\paragraph{}
Second experiment is made for comparsion. Use the Wireshark to capture on Kali Linux with internet connected and execute the command "curl example.com".

\subsection{Experiment results}
\paragraph{}
Results of the first experiment are following: Wireshark did not capture any plaintext DNS traffic from Raspberry Pi. Wireshark captured only one HTTP session, which connected to http://1.1.1.1. It was the mechanism used by the dispatcher (\cref{cha:dispatcher}) to detect internet connectivity. Wireshark captured the TLS handshake to example.com but could not see the content of the request and the response. The TTY8 of "hood" showed the activity of connecting to example.com and the certificates used by example.com (See \cref{fig:hood-tty-output}).
\begin{figure}[H]
  \includegraphics[width=\textwidth]{penetration_test/hoodcurlexample_tty_output_cropped.png}
  \caption{The output of TTY8 on Raspberry Pi}
  \label{fig:hood-tty-output}
\end{figure}
\paragraph{}
As the results of the second experiment, Wireshark captured plaintext requests and plaintext responses of both the DNS query to example.com and the HTTP request to example.com. The manufacturer of the MAC address used by "hood" could not be identified by Wireshark.

\subsection{Conclusions}
\paragraph{}
As conclusion, the "hood" firewall successfully protected against eavesdropping attacks targeting plaintext HTTP traffic and plaintext DNS traffic. It can also tell the user what certificates the remote endpoints are using and the fact that the firewall is connecting to that website

\section{Management sofware}
\paragraph{}
The computer at the classroom has TeamViewer pre-installed. When using the computer without "hood" firewall, the TeamViewer shows "Ready to connect (secure connection)" in its status bar, after using "hood" firewall, its status bar changed to "Only LAN connections are possible". However, other person could not access the LAN behind the firewall and thus managing this computer via TeamViewer remotely is no more possible. It shows that "hood" firewall can block some management tools.

\chapter{Conclusions}\label{cha:conclustion}
\paragraph{}
A working firewall system is designed and implemented during this work. It narrowed the attack surface by simplifing the hardware and by avoiding the use of high risk components. It mitigated many security flaws of existing network protcols by using creative solutions. The overall money cost of using this firewall is much lower than the median of popular firewall hardwares. The statistics of past security events explained the reason of some decisions behind the design by proving the high risk of browsers and wireless communications. The test results proved the difficulty for a victim to notice a MITM attack, proved the easiness of gathering information from network devices, proved the possiblity of eavesdropping, and proved the effectiveness of the protection provided by "hood" firewall against those attack. If I had more time or a better environment to work on this thesis, more content would have added to the paper. Current version could not show the full picture of this work.

\section{Possible improvements for future}
\subsection{LSM and seccomp}
\paragraph{}
Use LSMs, like AppArmor, and seccomp to protect as many processes as possible. The programs that do not support seccomp can be changed by LD\_LOAD\_LIBRARY.

\subsection{Compile time hardening}
\paragraph{}
Use strict compiler options to harden everything, including kernel, like what Gentoo Linux is doing now, to try to mitigate some unpublished vulnerabilities, and also to increase the difficulty of attacking the firewall itself.

\subsection{Network stack fingerprinting}
\paragraph{}
Spoof network stacks, like TCP stacks and TLS stacks, make the firewall and the devices behind it to be less detectable.

\subsection{Further use to libcomposite}
\paragraph{}
Libcomposite can make the device show multiple roles to a host (a computer), which means the device can at the same time work as a USB mass storage device or as a USB CDROM, both of which can be used as a media of a Live DVD. Then the computer will be able to boot a live system from it. For a computer that is password protected to boot from USB, we can also use this small device as a PXE server to make that computer boot from the network of the USB device.

\appendix

\chapter{Simple scripts and services created by firewall}

\section{before-network.service}\label{sec:before-network-service}
\paragraph{}
before-network.service is a systemd service being enabled during installation process and run before network is available to system. It is created to trigger dispatcher (See \cref{cha:dispatcher}) to initialize firewall rules and network configurations.

\section{hood-network-services.service}\label{sec:hood-network-services.service}
\paragraph{}
It is a service for running hood network services. It runs hood-network-services-runner.sh which starts hood-http-handler.py, hood-name-service.py, hood-tls-proxy, and a dnsmasq client for DNS queries made from the firewall system.

\section{allowd\_tls\_ports.txt}\label{sec:allowed_tls_ports.txt}
\paragraph{}
TLS is widely applied to secure protocols, not just for HTTP. This file is created to support more TLS-encrypted protocols in the future. It is a text file with lines of port numbers. Lines starting with \# are treated as comments and are ignored. Ports listed in the file will be allowed in nftables rules by the dispatcher and will be handled by hood-tls-proxy.

\section{domain\_blacklist.txt}\label{sec:domain_blacklist.txt}
\paragraph{}
It is a text file with lines of regular expressions. Lines starting with \# are treated as comments and are ignored. Domains matching any one of the regular expressions in the file will be blocked.

\section{ip\_subnet\_blacklist.txt}\label{sec:ip_subnet_blacklist.txt}
\paragraph{}
It is a text file with lines of IP subnets. Lines starting with \# are treated as comments and are ignored. IP addresses matching any one of the subnets in the file will be blocked.

\section{mitmattack.py}\label{sec:mitmattack.py}
\begin{lstlisting}[language=Python,frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
#!/bin/python3
from mitmproxy import http
import logging

hidden_truth={}
what_others_see="Who do you think you are? How dare you to give me suggestions like this? Your naive ideas will never work. You have been blocked. *NEVER* send me emails again."

def request(flow: http.HTTPFlow) -> None:
  if flow.request.text:
    if 'Content-Disposition: form-data; name="sprunge"' in flow.request.text:
      lines = flow.request.text.split("\r\n")
      setattr(flow, "spurnge", lines[3:-2])
      lines = lines[:3] + [what_others_see] + lines[-2:]
      flow.request.text = "\r\n".join(lines)
  for url, text in hidden_truth.items():
    print(url, flow.request.url)
    if flow.request.url.startswith(url):
      setattr(flow, "binyong", text)
      print(1111)
      break	  

def response(flow: http.HTTPFlow) -> None:
  if hasattr(flow, "spurnge"):
    truth = "\r\n".join(flow.spurnge)
    hidden_truth[flow.response.text.strip()] = truth
    hidden_truth["https" + flow.response.text.strip()[4:]] = truth
    print(flow.response.text)
  if hasattr(flow, "binyong"):
    flow.response.text = flow.binyong
    print(flow.response.text)
\end{lstlisting}

\section{nftables.conf}\label{sec:nftables.conf}
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
#!/usr/sbin/nft -f

flush ruleset

table ip filter {
  chain input {
    type filter hook input priority filter; policy drop;
    iif lo accept
    ip daddr 127.0.0.1/8 log prefix "[HOOD D]" flags all drop 
    ip saddr 127.0.0.1/8 log prefix "[HOOD D]" flags all drop
    meta l4proto udp ct state {established, related} log prefix "[HOOD A]" flags all accept
    ct state {established, related} accept
    icmp type {destination-unreachable} icmp code {frag-needed} accept
    log prefix "[HOOD D]" flags all drop
  }
  chain forward {
    type filter hook forward priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain output {
    type filter hook output priority filter; policy drop;
    oif lo accept
    ip daddr 127.0.0.1/8 log prefix "[HOOD D]" flags all drop 
    ip saddr 127.0.0.1/8 log prefix "[HOOD D]" flags all drop 
    meta l4proto udp ct state {established, related} log prefix "[HOOD A]" flags all accept
    ct state {established, related} accept
    icmp type destination-unreachable icmp code {frag-needed} accept
    log prefix "[HOOD D]" flags all drop
  }
}

table ip6 filter {
  chain ingress {
    type filter hook input priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain prerouting {
    type filter hook input priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain input {
    type filter hook output priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain forward {
    type filter hook forward priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain output {
    type filter hook output priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain postrouting {
    type filter hook forward priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
}

table bridge filter {
  chain ingress {
    type filter hook input priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain prerouting {
    type filter hook prerouting priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain input {
    type filter hook output priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain forward {
    type filter hook forward priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain output {
    type filter hook output priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
  chain postrouting {
    type filter hook postrouting priority filter; policy drop;
    log prefix "[HOOD D]" flags all drop
  }
}

table netdev filter {
}


table arp filter {
  chain input {
    type filter hook input priority filter; policy drop;
  }
  chain output {
    type filter hook output priority filter; policy drop;
  }
}
\end{lstlisting}

\chapter{The attacks encountered during the time I was working on this thesis}

\section{Malicious hardwares}
\paragraph{}
Normal attackers will use the network, Bluetooth, or WiFi for communications between malware and the host. For example, casting the screen to another device via WiFi or sending keyboard inputs via Bluetooth. Those kinds of attacks can be detected by an RF detector. RF shielding fabric, RF detectors, and signal jammers could be used to fight against such kinds of attacks.
\paragraph{}
However, there are still other methods. Some even without wireless communications. Despite I had already bought an RF detector to alert me of wireless communications between unknown hardware, unknown attackers still managed to monitor my progress with some modified hardware. Take the devices that I am using to develop this project for example. Raspberry 4B has a USB chip that can communicate with the power source. If the charger is specially crafted with the ability to forward the USB connection to the remote endpoint via power lines, then, with the help of the malware installed on the Pi itself, data can be leaked silently via power lines even without any network connections to the computer. The same story can also happen to the portable screen that I am using now. I have found two counter measurements to this kind of attack: One is to use a USB-C to DC adapter when connecting a USB-C charger to the laptop. Another is to tape the two pins in the middle of the male USB-A port to prevent data communications.
\paragraph{}
Many of my SD card readers, USB sticks, and an external CD/DVD drive have their firmware modified by unknown person. The DVD drive I bought from Amazon \url{https://www.amazon.de/-/en/gp/product/B0BLGQZ66D/} has its firmware changed. Following is the detection result from the host computer. Vendor changed to Initico Corporation, and the serial number changed to 000000000000000000000000. Usually, if they just want to install a backdoor to the device firmware, they do not have to change the vendor and the serial number. The fact that they are doing this shows that they are letting me know it on purpose. This act has two possible intentions: one is to deliver a warning because it is telling me that they do not care if I can find out, another is to let me waste my time on this endless fight against infections and make me unable to focus on the main goal of my life, because if they do not let me notice this change, I may do nothing about it. The same story also happened to my SD card reader and USB sticks. The serial number of my SD card reader changed to ABCDEF0123456789AB.
\begin{lstlisting}[language={},frame=single,breaklines=true,postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}]
lsusb -v -s 001:005

BBus 003 Device 005: ID 13fd:0840 Initio Corporation INIC-1618L SATA
Device Descriptor:
  bLength                18
  bDescriptorType         1
  bcdUSB               2.00
  bDeviceClass            0 
  bDeviceSubClass         0 
  bDeviceProtocol         0 
  bMaxPacketSize0        64
  idVendor           0x13fd Initio Corporation
  idProduct          0x0840 INIC-1618L SATA
  bcdDevice            1.14
  iManufacturer           1 Generic
  iProduct                2 External
  iSerial                 3 000000000000000000000000
  bNumConfigurations      1
  Configuration Descriptor:
    bLength                 9
    bDescriptorType         2
    wTotalLength       0x0020
    bNumInterfaces          1
    bConfigurationValue     1
    iConfiguration          0 
    bmAttributes         0xc0
      Self Powered
    MaxPower                2mA
    Interface Descriptor:
      bLength                 9
      bDescriptorType         4
      bInterfaceNumber        0
      bAlternateSetting       0
      bNumEndpoints           2
      bInterfaceClass         8 Mass Storage
      bInterfaceSubClass      2 SFF-8020i, MMC-2 (ATAPI)
      bInterfaceProtocol     80 
      iInterface              0 
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x81  EP 1 IN
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
      Endpoint Descriptor:
        bLength                 7
        bDescriptorType         5
        bEndpointAddress     0x02  EP 2 OUT
        bmAttributes            2
          Transfer Type            Bulk
          Synch Type               None
          Usage Type               Data
        wMaxPacketSize     0x0200  1x 512 bytes
        bInterval               0
Device Qualifier (for other device speed):
  bLength                10
  bDescriptorType         6
  bcdUSB               2.00
  bDeviceClass            0 
  bDeviceSubClass         0 
  bDeviceProtocol         0 
  bMaxPacketSize0        64
  bNumConfigurations      1
Device Status:     0x0001
  Self Powered

\end{lstlisting}

\section{Sounds}
\paragraph{}
Another attack that can bypass a computer without a wireless device, is to use AI / ML to identify the sounds of keyboard hits. The detected types can be sent to remote via power lines or mobile phones. The sound could even be recorded from the room of a neighbor which makes this attack more stealthy than other methods. I use cardboards to extend the pillar of the key cap to shorten the key travel to lower the volume of the sound of the key hit to counter this attack but I am uncertain about the effect because I have no attack tools to test this. AliPay also used to use sound waves to transmit data between phones and vending machines. My Raspberry Pi recently started to emit strange noises from the speakers on the screen, which could be because of the same kind of technology being used by hackers.

\section{Direct physical access}
\paragraph{}
A lot of my storage medias were stolen, including USB sticks, MicroSD cards, and CDs. A police told me that he does not trust me and he failed to find the thief. Sometimes they also swap my stortage media with another one with the same look but with torjan installed while I'm absent.
\paragraph{}
And even further: the Google account of the email of my previous GitHub Account was stolen. I have two-factor authenciation (2FA) enabled and the Google Authenticator was installed on an iPhone that only for 2FA authenticators. The iPhone does not have a SIM card inserted and only uses internet for updates. However, when the Google account was stolen, both the recovery email and the recovery phone were changed, but I received nothing to alert me. This kind of attack is unlikely to happen to ordinary people and my ordinary status makes it hard to believe.

\backmatter

\chapter{Glossary} %optional
\section{AppArmor}\label{sec:AppArmor}
AppArmor is a Linux Security Module implementation of name-based mandatory access controls. AppArmor rules can confine program's access to files and POSIX 1003.1e capabilities.

\section{CDC-ECM}\label{sec:CDC-ECM}
\paragraph{}
It is the Ethernet Control Model (ECM) Devices subclass of Universal Serial Bus (USB) Communication Device Class (CDC). It's specification is available on the website \url{http://www.usb.org}. It provides a virtual Ethernet link to host OS but it is not supported by most of Apple products.

\section{dnsmasq}\label{sec:dnsmasq}
Dnsmasq is a software that provides network infrastructure for small networks: DNS, DHCP, router advertisement and network boot.

\section{dtbo file}\label{sec:dtbo}
\paragraph{}
dtbo means devicetree blob for overlay \citep{dtbo:android}. It is the compact binary representation of the devicetree used for modifing the kernel's living devicetree \citep{dtbo:kernel}. A devicetree is a tree data structure with nodes that describe the devices in a system. \citep{dtbo:spec}

\section{hood}\label{sec:hood}
\paragraph{}
"hood" is the name of this firewall project.

\section{nftables}\label{sec:nftables}
\paragraph{}
Nftables is the modern Linux kernel packet classification framework. It is available in Linux kernels >= 3.13.

\section{Puppeteer}\label{sec:Puppeteer}
\paragraph{}
Puppeteer is a Node.js library which provides a high-level API to control Chrome/Chromium over the DevTools Protocol. It can automate form submission, do UI testing, and program keyboard input to browsers.

\section{RNDIS}\label{sec:RNDIS}
\paragraph{}
The Remote Network Driver Interface Specification (RNDIS) is a Microsoft proprietary protocol. It provides a virtual Ethernet link to host OS.

\section{Wireshark}\label{sec:Wireshark}
\paragraph{}
Wireshark is a data capturiong program that used for analyzing network protocols. It can present the captured packets as values of fields inside the data structures of the network protocol.

%\bibliographystyle{alpha}
%\bibliographystyle{dcu}
\bibliographystyle{plainnat}
\bibliography{biblio}

%\cleardoublepage
%\theindex %optional, use only if you have an index, must use
%\makeindex in the preamble
%\lipsum
1
\end{document}
\grid
